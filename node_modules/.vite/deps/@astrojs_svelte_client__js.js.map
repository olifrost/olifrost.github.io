{
  "version": 3,
  "sources": ["../../@astrojs/svelte/client.svelte.js"],
  "sourcesContent": ["import { createRawSnippet, hydrate, mount, unmount } from 'svelte';\n\n/** @type {WeakMap<any, ReturnType<typeof createComponent>} */\nconst existingApplications = new WeakMap();\n\nexport default (element) => {\n\treturn async (Component, props, slotted, { client }) => {\n\t\tif (!element.hasAttribute('ssr')) return;\n\n\t\tlet children = undefined;\n\t\tlet _$$slots = undefined;\n\t\tlet renderFns = {};\n\n\t\tfor (const [key, value] of Object.entries(slotted)) {\n\t\t\t// Legacy slot support\n\t\t\t_$$slots ??= {};\n\t\t\tif (key === 'default') {\n\t\t\t\t_$$slots.default = true;\n\t\t\t\tchildren = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot>${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\t_$$slots[key] = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot name=\"${key}\">${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t}\n\t\t\t// @render support for Svelte ^5.0\n\t\t\tif (key === 'default') {\n\t\t\t\trenderFns.children = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot>${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\trenderFns[key] = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot name=\"${key}\">${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tconst resolvedProps = {\n\t\t\t...props,\n\t\t\tchildren,\n\t\t\t$$slots: _$$slots,\n\t\t\t...renderFns,\n\t\t};\n\t\tif (existingApplications.has(element)) {\n\t\t\texistingApplications.get(element).setProps(resolvedProps);\n\t\t} else {\n\t\t\tconst component = createComponent(Component, element, resolvedProps, client !== 'only');\n\t\t\texistingApplications.set(element, component);\n\t\t\telement.addEventListener('astro:unmount', () => component.destroy(), { once: true });\n\t\t}\n\t};\n};\n\n/**\n * @param {any} Component\n * @param {HTMLElement} target\n * @param {Record<string, any>} props\n * @param {boolean} shouldHydrate\n */\nfunction createComponent(Component, target, props, shouldHydrate) {\n\tlet propsState = $state(props);\n\tconst bootstrap = shouldHydrate ? hydrate : mount;\n\tconst component = bootstrap(Component, { target, props: propsState });\n\treturn {\n\t\tsetProps(newProps) {\n\t\t\tObject.assign(propsState, newProps);\n\t\t\t// Remove props in `propsState` but not in `newProps`\n\t\t\tfor (const key in propsState) {\n\t\t\t\tif (!(key in newProps)) {\n\t\t\t\t\tdelete propsState[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdestroy() {\n\t\t\tunmount(component);\n\t\t},\n\t};\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;IAGM,uBAAoB,oBAAO,QAAO;6BAExB,YAAY;gBACb,WAAW,OAAO,SAAO,EAAI,OAAM,MAAO;SAClD,QAAQ,aAAa,KAAK,EAAA;QAE3B,WAAW;QACX,WAAW;QACX,YAAS,CAAA;gBAED,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AAEnD,8BAAQ,CAAA;wBACJ,KAAQ,SAAS,GAAE;AACtB,iBAAS,UAAU;AACnB,mBAAW,iBAAgB,OAAA;UAC1B,QAAM,MAAA,eAAuB,KAAK;;MAEpC,OAAO;AACN,iBAAS,GAAG,IAAI,iBAAgB,OAAA;UAC/B,QAAM,MAAA,qBAA6B,GAAG,KAAK,KAAK;;MAElD;wBAEI,KAAQ,SAAS,GAAE;AACtB,kBAAU,WAAW,iBAAgB,OAAA;UACpC,QAAM,MAAA,eAAuB,KAAK;;MAEpC,OAAO;AACN,kBAAU,GAAG,IAAI,iBAAgB,OAAA;UAChC,QAAM,MAAA,qBAA6B,GAAG,KAAK,KAAK;;MAElD;IACD;UAEM,gBAAa;SACf;MACH;MACA,SAAS;SACN;;QAEA,qBAAqB,IAAI,OAAO,GAAG;AACtC,2BAAqB,IAAI,OAAO,EAAE,SAAS,aAAa;IACzD,OAAO;YACA,YAAY,gBAAgB,WAAW,SAAS,eAAa,cAAE,QAAW,QAAM,KAAA,CAAA;AACtF,2BAAqB,IAAI,SAAS,SAAS;AAC3C,cAAQ,iBAAiB,iBAAe,MAAQ,UAAU,QAAO,GAAA,EAAM,MAAM,KAAI,CAAA;IAClF;EACD;AACD;SAQS,gBAAgB,WAAW,QAAQ,OAAO,eAAe;MAC7D,aAAU,MAAU,KAAK;QACvB,YAAY,gBAAgB,UAAU;QACtC,YAAY,UAAU,WAAS,EAAI,QAAQ,OAAO,WAAU,CAAA;;IAEjE,SAAS,UAAU;AAClB,aAAO,OAAO,YAAY,QAAQ;iBAEvB,OAAO,YAAY;cACvB,OAAO,WAAW;iBAChB,WAAW,GAAG;QACtB;MACD;IACD;IACA,UAAU;AACT,cAAQ,SAAS;IAClB;;AAEF;",
  "names": []
}
